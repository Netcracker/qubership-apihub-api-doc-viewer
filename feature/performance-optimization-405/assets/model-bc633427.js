import{i as m,G as D,H as T,K as q,M as N,O as v,P as E,Q as O,R,T as b,V as C,W as $,X as h,Y as g,Z as j,_ as x,$ as k,a0 as A}from"./ErrorBoundaryFallback-b09b2616.js";class I{static calculateNodeChangesSummary(i,e,s){if(!s)return;const{crawlValue:o}=s;if(!V(o,e))return;const c=o[e];i.meta.$nodeChangesSummary=new Set(Array.from(c).map(n=>n.type))}}function V(l,i){if(!m(l)||!l[i])return!1;const e=l[i];return w(e)}function w(l){if(!(l instanceof Set))return!1;for(const i of l)if(!i||!D(i))return!1;return!0}const J=new Set(["required"]);class H extends T{constructor(i,e){super(i),this.metaKeys=e}createNode(i,e,s,o,c,n){const r=super.createNode(i,e,s,o,c,n);return I.calculateNodeChangesSummary(r,this.metaKeys.aggregatedDiffsMetaKey,n),r}createComplexNode(i,e,s,o,c,n){const r=super.createComplexNode(i,e,s,o,c,n);return I.calculateNodeChangesSummary(r,this.metaKeys.aggregatedDiffsMetaKey,n),r}createCycledClone(i,e,s,o){return super.createCycledClone(i,e,s,o)}createNodeMeta(i){const{value:e}=i;return q(e)==="simple"?this.simpleDiffMeta(i):this.nestedDiffMeta(i)}createNodeValue(i){const{value:e}=i;if(e==null)return null;if(!m(e))return e;const s=N(e.type)?e.type:v;let o=O[s];const c=e[this.metaKeys.diffsMetaKey];if(m(c)&&"type"in c){const r=c.type,t=D(r)&&E(r)&&N(r.beforeValue)?r.beforeValue:void 0;o=[...o,...t?O[t]:[]]}const n=this.getPropsChanges(e,o);return{...R(e,o),...Object.keys(n).length?{$changes:n}:{}}}getPropsChanges(i,e){const s={};if(!m(i))return s;const o=b(i.required);if(o){const t=o[this.metaKeys.diffsMetaKey];if(C(t))for(const a of Object.keys(t)){const d=t[a];$(s,d,"required",a)}}const c=b(i.enum);if(c){const t=c[this.metaKeys.diffsMetaKey];if(C(t))for(const a of Object.keys(t)){const d=t[a];$(s,d,"enum",a)}}const n=b(i.examples);if(n){const t=n[this.metaKeys.diffsMetaKey];if(C(t))for(const a of Object.keys(t)){const d=t[a];$(s,d,"examples",a)}}const r=e.filter(t=>!J.has(t));for(const t of r){const a=i[this.metaKeys.diffsMetaKey];if(!C(a))continue;const d=a[t];if(!D(d))continue;$(s,d,...[t])}return s}isAllDescendantsChanged(i,e,s,o){let c=!1;if(s){const n=i.children().map(t=>t.id),r=Object.entries(s).filter(([,t])=>t&&!!Object.keys(t).length).map(([t])=>t);c=n.length>0&&r.length>0&&n.length===r.length&&n.every(t=>r.includes(t))&&r.every(t=>s[t].action===s[n[0]].action)}if(o){const n=e.nested.map(t=>t.id),r=Object.entries(o).filter(([,t])=>t&&!!Object.keys(t).length).map(([t])=>t);c=n.length>0&&r.length>0&&n.length===r.length&&n.every(t=>r.includes(t))&&r.every(t=>o[t].action===o[n[0]].action)}return c}getNodeChange(i){var d,y,u,p;const{id:e,parent:s=null,container:o=null}=i,c=((d=o==null?void 0:o.meta)==null?void 0:d.$nodeChange)??((y=s==null?void 0:s.meta)==null?void 0:y.$nodeChange),n=(u=s==null?void 0:s.meta)==null?void 0:u.$childrenChanges,r=(p=o==null?void 0:o.meta)==null?void 0:p.$nestedChanges,t=(n==null?void 0:n[e])||(r==null?void 0:r[e]),a=this.isAllDescendantsChanged;return["add","remove"].includes((c==null?void 0:c.action)??"")?c:t?{...t,get depth(){const K=a(s,o,n,r);return((s==null?void 0:s.depth)??0)+(K?0:1)}}:void 0}getRequiredChange(i,e){if(!e||typeof i=="number"||!i)return null;const s=e==null?void 0:e.value(),o=s==null?void 0:s.$changes;if(o&&"required"in o&&s&&"required"in s&&Array.isArray(s.required)&&s.required.includes(i)&&o.required){const c=s.required.indexOf(i).toString();if(c in o.required)return o.required[c]}return null}getChildrenChanges(i,e){var n,r,t,a,d,y,u,p,K,P,S;const s={};if((n=e==null?void 0:e[this.metaKeys.diffsMetaKey])!=null&&n.properties)for(const f of h(e.properties))s[`${i}/properties/${f}`]=(r=e==null?void 0:e[this.metaKeys.diffsMetaKey])==null?void 0:r.properties;const o=((t=e.properties)==null?void 0:t[this.metaKeys.diffsMetaKey])??{};for(const f of h(o))s[`${i}/properties/${f}`]=o[f];if((a=e==null?void 0:e[this.metaKeys.diffsMetaKey])!=null&&a.additionalProperties&&(s[`${i}/additionalProperties`]=e[this.metaKeys.diffsMetaKey].additionalProperties),(d=e==null?void 0:e.items)!=null&&d[this.metaKeys.diffsMetaKey]){const f=((y=e==null?void 0:e.items)==null?void 0:y[this.metaKeys.diffsMetaKey])??{};for(const M of h(f))s[`${i}/items/${M.toString()}`]=f[M]}if((u=e==null?void 0:e[this.metaKeys.diffsMetaKey])!=null&&u.items){const f=e==null?void 0:e.items;if(g(f))for(const M of h(f))s[`${i}/items/${M.toString()}`]=e==null?void 0:e[this.metaKeys.diffsMetaKey].items;else s[`${i}/items`]=e==null?void 0:e[this.metaKeys.diffsMetaKey].items}if((p=e==null?void 0:e[this.metaKeys.diffsMetaKey])!=null&&p.additionalItems&&(s[`${i}/additionalItems`]=e[this.metaKeys.diffsMetaKey].additionalItems),(K=e==null?void 0:e[this.metaKeys.diffsMetaKey])!=null&&K.patternProperties)for(const f of h(e.patternProperties))s[`${i}/patternProperties${j([f])}`]=(P=e==null?void 0:e[this.metaKeys.diffsMetaKey])==null?void 0:P.patternProperties;const c=((S=e==null?void 0:e.patternProperties)==null?void 0:S[this.metaKeys.diffsMetaKey])??{};for(const f of h(c))s[`${i}/patternProperties${j([f])}`]=c[f];return s}simpleDiffMeta(i){const{value:e,id:s,key:o="",parent:c=null}=i,n=this.getRequiredChange(o,c),r={...n?{required:n}:{},...this.getPropsChanges(e,x)},t=this.getChildrenChanges(s,e??{}),a=this.getNodeChange(i);return{...R(e,x),...a?{$nodeChange:a}:{},...Object.keys(r).length?{$metaChanges:r}:{},...Object.keys(t).length?{$childrenChanges:t}:{},$nodeChangesSummary:new Set,required:k(o,c),...A(e)?{brokenRef:e.$ref}:{},_fragment:e}}nestedDiffMeta(i){var d;const{value:e,id:s,key:o="",parent:c=null}=i,n=q(e),r=((d=e==null?void 0:e[n])==null?void 0:d[this.metaKeys.diffsMetaKey])??{},t=this.getNodeChange(i),a={};for(const y of Object.keys(r))a[`${s}/${n}/${y}`]=r[y];return{...Object.keys(a).length?{$nestedChanges:a}:{},...t?{$nodeChange:t}:{},$nodeChangesSummary:new Set,required:k(o,c),...A(e)?{brokenRef:e.$ref}:{},_fragment:e}}}export{H as J};
