import{i as $,t as D,u as v,v as N,w as q,U as E,x as T,y as O,z as j,A as b,B as C,F as m,G as h,H as g,K as x,M as R,N as k,O as A}from"./ErrorBoundaryFallback-e266333d.js";class I{static calculateNodeChangesSummary(i,e,s){if(!s)return;const{crawlValue:o}=s;if(!w(o,e))return;const c=o[e];i.meta.$nodeChangesSummary=new Set(Array.from(c).map(n=>n.type))}}function w(l,i){if(!$(l)||!l[i])return!1;const e=l[i];return V(e)}function V(l){if(!(l instanceof Set))return!1;for(const i of l)if(!i||!D(i))return!1;return!0}const F=new Set(["required"]);class H extends v{constructor(i,e){super(i),this.metaKeys=e}createNode(i,e,s,o,c,n){const r=super.createNode(i,e,s,o,c,n);return I.calculateNodeChangesSummary(r,this.metaKeys.aggregatedDiffsMetaKey,n),r}createComplexNode(i,e,s,o,c,n){const r=super.createComplexNode(i,e,s,o,c,n);return I.calculateNodeChangesSummary(r,this.metaKeys.aggregatedDiffsMetaKey,n),r}createCycledClone(i,e,s,o){return super.createCycledClone(i,e,s,o)}createNodeMeta(i){const{value:e}=i;return N(e)==="simple"?this.simpleDiffMeta(i):this.nestedDiffMeta(i)}createNodeValue(i){const{value:e}=i;if(e==null)return null;if(!$(e))return e;const s=q(e.type)?e.type:E;let o=O[s];const c=e[this.metaKeys.diffsMetaKey];if($(c)&&"type"in c){const r=c.type,t=D(r)&&T(r)&&q(r.beforeValue)?r.beforeValue:void 0;o=[...o,...t?O[t]:[]]}const n=this.getPropsChanges(e,o);return{...j(e,o),...Object.keys(n).length?{$changes:n}:{}}}getPropsChanges(i,e){const s={};if(!$(i))return s;const o=b(i.required);if(o){const t=o[this.metaKeys.diffsMetaKey];if(C(t))for(const d of Object.keys(t)){const a=t[d];m(s,a,"required",d)}}const c=b(i.enum);if(c){const t=c[this.metaKeys.diffsMetaKey];if(C(t))for(const d of Object.keys(t)){const a=t[d];m(s,a,"enum",d)}}const n=b(i.examples);if(n){const t=n[this.metaKeys.diffsMetaKey];if(C(t))for(const d of Object.keys(t)){const a=t[d];m(s,a,"examples",d)}}const r=e.filter(t=>!F.has(t));for(const t of r){const d=i[this.metaKeys.diffsMetaKey];if(!C(d))continue;const a=d[t];if(!D(a))continue;m(s,a,...[t])}return s}isAllDescendantsChanged(i,e,s,o){let c=!1;if(s){const n=i.children().map(t=>t.id),r=Object.entries(s).filter(([,t])=>t&&!!Object.keys(t).length).map(([t])=>t);c=n.length>0&&r.length>0&&n.length===r.length&&n.every(t=>r.includes(t))&&r.every(t=>s[t].action===s[n[0]].action)}if(o){const n=e.nested.map(t=>t.id),r=Object.entries(o).filter(([,t])=>t&&!!Object.keys(t).length).map(([t])=>t);c=n.length>0&&r.length>0&&n.length===r.length&&n.every(t=>r.includes(t))&&r.every(t=>o[t].action===o[n[0]].action)}return c}getNodeChange(i){var a,f,u,p;const{id:e,parent:s=null,container:o=null}=i,c=((a=o==null?void 0:o.meta)==null?void 0:a.$nodeChange)??((f=s==null?void 0:s.meta)==null?void 0:f.$nodeChange),n=(u=s==null?void 0:s.meta)==null?void 0:u.$childrenChanges,r=(p=o==null?void 0:o.meta)==null?void 0:p.$nestedChanges,t=(n==null?void 0:n[e])||(r==null?void 0:r[e]),d=this.isAllDescendantsChanged;return["add","remove"].includes((c==null?void 0:c.action)??"")?c:t?{...t,get depth(){const K=d(s,o,n,r);return((s==null?void 0:s.depth)??0)+(K?0:1)}}:void 0}getRequiredChange(i,e){if(!e||typeof i=="number"||!i)return null;const s=e==null?void 0:e.value(),o=s==null?void 0:s.$changes;if(o&&"required"in o&&s&&"required"in s&&Array.isArray(s.required)&&s.required.includes(i)&&o.required){const c=s.required.indexOf(i).toString();if(c in o.required)return o.required[c]}return null}getChildrenChanges(i,e){var n,r,t,d,a,f,u,p,K,P,S;const s={};if((n=e==null?void 0:e[this.metaKeys.diffsMetaKey])!=null&&n.properties)for(const y of h(e.properties))s[`${i}/properties/${y}`]=(r=e==null?void 0:e[this.metaKeys.diffsMetaKey])==null?void 0:r.properties;const o=((t=e.properties)==null?void 0:t[this.metaKeys.diffsMetaKey])??{};for(const y of h(o))s[`${i}/properties/${y}`]=o[y];if((d=e==null?void 0:e[this.metaKeys.diffsMetaKey])!=null&&d.additionalProperties&&(s[`${i}/additionalProperties`]=e[this.metaKeys.diffsMetaKey].additionalProperties),(a=e==null?void 0:e.items)!=null&&a[this.metaKeys.diffsMetaKey]){const y=((f=e==null?void 0:e.items)==null?void 0:f[this.metaKeys.diffsMetaKey])??{};for(const M of h(y))s[`${i}/items/${M.toString()}`]=y[M]}if((u=e==null?void 0:e[this.metaKeys.diffsMetaKey])!=null&&u.items){const y=e==null?void 0:e.items;if(g(y))for(const M of h(y))s[`${i}/items/${M.toString()}`]=e==null?void 0:e[this.metaKeys.diffsMetaKey].items;else s[`${i}/items`]=e==null?void 0:e[this.metaKeys.diffsMetaKey].items}if((p=e==null?void 0:e[this.metaKeys.diffsMetaKey])!=null&&p.additionalItems&&(s[`${i}/additionalItems`]=e[this.metaKeys.diffsMetaKey].additionalItems),(K=e==null?void 0:e[this.metaKeys.diffsMetaKey])!=null&&K.patternProperties)for(const y of h(e.patternProperties))s[`${i}/patternProperties${x([y])}`]=(P=e==null?void 0:e[this.metaKeys.diffsMetaKey])==null?void 0:P.patternProperties;const c=((S=e==null?void 0:e.patternProperties)==null?void 0:S[this.metaKeys.diffsMetaKey])??{};for(const y of h(c))s[`${i}/patternProperties${x([y])}`]=c[y];return s}simpleDiffMeta(i){const{value:e,id:s,key:o="",parent:c=null}=i,n=this.getRequiredChange(o,c),r={...n?{required:n}:{},...this.getPropsChanges(e,R)},t=this.getChildrenChanges(s,e??{}),d=this.getNodeChange(i);return{...j(e,R),...d?{$nodeChange:d}:{},...Object.keys(r).length?{$metaChanges:r}:{},...Object.keys(t).length?{$childrenChanges:t}:{},$nodeChangesSummary:new Set,required:k(o,c),...A(e)?{brokenRef:e.$ref}:{},_fragment:e}}nestedDiffMeta(i){var a;const{value:e,id:s,key:o="",parent:c=null}=i,n=N(e),r=((a=e==null?void 0:e[n])==null?void 0:a[this.metaKeys.diffsMetaKey])??{},t=this.getNodeChange(i),d={};for(const f of Object.keys(r))d[`${s}/${n}/${f}`]=r[f];return{...Object.keys(d).length?{$nestedChanges:d}:{},...t?{$nodeChange:t}:{},$nodeChangesSummary:new Set,required:k(o,c),...A(e)?{brokenRef:e.$ref}:{},_fragment:e}}}export{H as J};
