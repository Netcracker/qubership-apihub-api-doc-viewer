import{u as S,v as R,w as f,x as v,y as M,z as q,i as m,A as D,U as w,B as A,F as I,G as g,H as K,o as V,K as u,M as E,N as J,O as j,P as k,Q as O,R as T}from"./ErrorBoundaryFallback-3a918a35.js";class U{changesSummary(t,e){var s;if(S(e,t.meta.$metaChanges),S(e,t.meta.$childrenChanges),S(e,t.meta.$nestedChanges),t.type==="simple"){const{required:i,...o}=((s=t.value())==null?void 0:s.$changes)??{};S(e,o)}}totalChangesSummary(t){const e=new Set;return t.isCycle||(this.changesSummary(t,e),!e.size)||this.updateParentNodesChangesSummary(t,e),e}updateParentNodesChangesSummary(t,e){const s=R(t)?t.container:t.parent;s&&(f(e,s.meta.$nodeChangesSummary)||(s.meta.$nodeChangesSummary=v(e,s.meta.$nodeChangesSummary),this.updateParentNodesChangesSummary(s,e)))}}const P=new U;class F extends M{constructor(t,e){super(t),this.metaKey=e}createNode(t,e,s,i,o){const r=super.createNode(t,e,s,i,o);return r.meta.$nodeChangesSummary=P.totalChangesSummary(r),r}createComplexNode(t,e,s,i,o){const r=super.createComplexNode(t,e,s,i,o);return r.meta.$nodeChangesSummary=P.totalChangesSummary(r),r}createCycledClone(t,e,s,i){const o=super.createCycledClone(t,e,s,i);return o.meta.$nodeChangesSummary=P.totalChangesSummary(o),o}createNodeMeta(t){const{value:e}=t;return q(e)==="simple"?this.simpleDiffMeta(t):this.nestedDiffMeta(t)}createNodeValue(t){const{value:e}=t;if(e==null)return null;if(!m(e))return e;const s=D(e.type)?e.type:w;let i=g[s];const o=e[this.metaKey];if(m(o)&&"type"in o){const c=o.type,n=A(c)&&I(c)&&D(c.beforeValue)?c.beforeValue:void 0;i=[...i,...n?g[n]:[]]}const r=this.getPropsChanges(e,i);return{...K(e,i),...Object.keys(r).length?{$changes:r}:{}}}getPropsChanges(t,e){const s={},i=new Set;return V(t,({value:o,path:r,key:c})=>{if(i.has(o))return{done:!0};if(i.add(o),r.length===1&&!e.includes(String(c)))return{done:!0};if(!m(o)||!(this.metaKey in o))return{value:o};const n=r.length?o[this.metaKey]:K(o[this.metaKey],e);for(const h of u(n)){const d=[...r,h];E(s,n[h],...d)}}),s}isAllDescendantsChanged(t,e,s,i){let o=!1;if(s){const r=t.children().map(n=>n.id),c=Object.entries(s).filter(([,n])=>n&&!!Object.keys(n).length).map(([n])=>n);o=r.length>0&&c.length>0&&r.length===c.length&&r.every(n=>c.includes(n))&&c.every(n=>s[n].action===s[r[0]].action)}if(i){const r=e.nested.map(n=>n.id),c=Object.entries(i).filter(([,n])=>n&&!!Object.keys(n).length).map(([n])=>n);o=r.length>0&&c.length>0&&r.length===c.length&&r.every(n=>c.includes(n))&&c.every(n=>i[n].action===i[r[0]].action)}return o}getNodeChange(t){var d,l,y,p;const{id:e,parent:s=null,container:i=null}=t,o=((d=i==null?void 0:i.meta)==null?void 0:d.$nodeChange)??((l=s==null?void 0:s.meta)==null?void 0:l.$nodeChange),r=(y=s==null?void 0:s.meta)==null?void 0:y.$childrenChanges,c=(p=i==null?void 0:i.meta)==null?void 0:p.$nestedChanges,n=(r==null?void 0:r[e])||(c==null?void 0:c[e]),h=this.isAllDescendantsChanged;return["add","remove"].includes((o==null?void 0:o.action)??"")?o:n?{...n,get depth(){const C=h(s,i,r,c);return((s==null?void 0:s.depth)??0)+(C?0:1)}}:void 0}getRequiredChange(t,e){if(!e||typeof t=="number"||!t)return null;const s=e==null?void 0:e.value(),i=s==null?void 0:s.$changes;if(i&&"required"in i&&s&&"required"in s&&Array.isArray(s.required)&&s.required.includes(t)&&i.required){const o=s.required.indexOf(t).toString();if(o in i.required)return i.required[o]}return null}getChildrenChanges(t,e){var r,c,n,h,d,l,y,p,C,N,b;const s={};if((r=e==null?void 0:e[this.metaKey])!=null&&r.properties)for(const a of u(e.properties))s[`${t}/properties/${a}`]=(c=e==null?void 0:e[this.metaKey])==null?void 0:c.properties;const i=((n=e.properties)==null?void 0:n[this.metaKey])??{};for(const a of u(i))s[`${t}/properties/${a}`]=i[a];if((h=e==null?void 0:e[this.metaKey])!=null&&h.additionalProperties&&(s[`${t}/additionalProperties`]=e[this.metaKey].additionalProperties),(d=e==null?void 0:e.items)!=null&&d[this.metaKey]){const a=((l=e==null?void 0:e.items)==null?void 0:l[this.metaKey])??{};for(const $ of u(a))s[`${t}/items/${$.toString()}`]=a[$]}if((y=e==null?void 0:e[this.metaKey])!=null&&y.items){const a=e==null?void 0:e.items;if(J(a))for(const $ of u(a))s[`${t}/items/${$.toString()}`]=e==null?void 0:e[this.metaKey].items;else s[`${t}/items`]=e==null?void 0:e[this.metaKey].items}if((p=e==null?void 0:e[this.metaKey])!=null&&p.additionalItems&&(s[`${t}/additionalItems`]=e[this.metaKey].additionalItems),(C=e==null?void 0:e[this.metaKey])!=null&&C.patternProperties)for(const a of u(e.patternProperties))s[`${t}/patternProperties${j([a])}`]=(N=e==null?void 0:e[this.metaKey])==null?void 0:N.patternProperties;const o=((b=e==null?void 0:e.patternProperties)==null?void 0:b[this.metaKey])??{};for(const a of u(o))s[`${t}/patternProperties${j([a])}`]=o[a];return s}simpleDiffMeta(t){const{value:e,id:s,key:i="",parent:o=null}=t,r=this.getRequiredChange(i,o),c={...r?{required:r}:{},...this.getPropsChanges(e,k)},n=this.getChildrenChanges(s,e??{}),h=this.getNodeChange(t);return{...K(e,k),...h?{$nodeChange:h}:{},...Object.keys(c).length?{$metaChanges:c}:{},...Object.keys(n).length?{$childrenChanges:n}:{},$nodeChangesSummary:new Set,required:O(i,o),...T(e)?{brokenRef:e.$ref}:{},_fragment:e}}nestedDiffMeta(t){var d;const{value:e,id:s,key:i="",parent:o=null}=t,r=q(e),c=((d=e==null?void 0:e[r])==null?void 0:d[this.metaKey])??{},n=this.getNodeChange(t),h={};for(const l of u(c))h[`${s}/${r}/${l}`]=c[l];return{...Object.keys(h).length?{$nestedChanges:h}:{},...n?{$nodeChange:n}:{},$nodeChangesSummary:new Set,required:O(i,o),...T(e)?{brokenRef:e.$ref}:{},_fragment:e}}}export{F as J};
