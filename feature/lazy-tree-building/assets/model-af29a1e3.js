import{i as D,v as P,w as v,x as q,y as O,U as g,z as E,A as M,B as j,F as K,G as b,H as m,K as y,M as T,N as x,O as R,P as k,Q as A}from"./ErrorBoundaryFallback-c3594ea4.js";class I{static calculateNodeChangesSummary(o,e,t){if(!t)return;const{crawlValue:i}=t;if(!w(i,e))return;const c=i[e];o.meta.$nodeChangesSummary=new Set(Array.from(c).map(n=>n.type))}}function w(u,o){if(!D(u)||!u[o])return!1;const e=u[o];return V(e)}function V(u){if(!(u instanceof Set))return!1;for(const o of u)if(!o||!P(o))return!1;return!0}const F=new Set(["required"]);class H extends v{constructor(o,e,t){super(o),this.metaKey=e,this.aggregatedMetaKey=t}createNode(o,e,t,i,c,n){const r=super.createNode(o,e,t,i,c,n);return I.calculateNodeChangesSummary(r,this.aggregatedMetaKey,n),r}createComplexNode(o,e,t,i,c,n){const r=super.createComplexNode(o,e,t,i,c,n);return I.calculateNodeChangesSummary(r,this.aggregatedMetaKey,n),r}createCycledClone(o,e,t,i){return super.createCycledClone(o,e,t,i)}createNodeMeta(o){const{value:e}=o;return q(e)==="simple"?this.simpleDiffMeta(o):this.nestedDiffMeta(o)}createNodeValue(o){const{value:e}=o;if(e==null)return null;if(!D(e))return e;const t=O(e.type)?e.type:g;let i=M[t];const c=e[this.metaKey];if(D(c)&&"type"in c){const r=c.type,s=P(r)&&E(r)&&O(r.beforeValue)?r.beforeValue:void 0;i=[...i,...s?M[s]:[]]}const n=this.getPropsChanges(e,i);return{...j(e,i),...Object.keys(n).length?{$changes:n}:{}}}getPropsChanges(o,e){const t={};if(!D(o))return t;const i=K(o.required);if(i){const s=i[this.metaKey];if(b(s))for(const d of Object.keys(s)){const a=s[d];m(t,a,"required",d)}}const c=K(o.enum);if(c){const s=c[this.metaKey];if(b(s))for(const d of Object.keys(s)){const a=s[d];m(t,a,"enum",d)}}const n=K(o.examples);if(n){const s=n[this.metaKey];if(b(s))for(const d of Object.keys(s)){const a=s[d];m(t,a,"examples",d)}}const r=e.filter(s=>!F.has(s));for(const s of r){const d=o[this.metaKey];if(!b(d))continue;const a=d[s];if(!P(a))continue;m(t,a,...[s])}return t}isAllDescendantsChanged(o,e,t,i){let c=!1;if(t){const n=o.children().map(s=>s.id),r=Object.entries(t).filter(([,s])=>s&&!!Object.keys(s).length).map(([s])=>s);c=n.length>0&&r.length>0&&n.length===r.length&&n.every(s=>r.includes(s))&&r.every(s=>t[s].action===t[n[0]].action)}if(i){const n=e.nested.map(s=>s.id),r=Object.entries(i).filter(([,s])=>s&&!!Object.keys(s).length).map(([s])=>s);c=n.length>0&&r.length>0&&n.length===r.length&&n.every(s=>r.includes(s))&&r.every(s=>i[s].action===i[n[0]].action)}return c}getNodeChange(o){var a,h,p,f;const{id:e,parent:t=null,container:i=null}=o,c=((a=i==null?void 0:i.meta)==null?void 0:a.$nodeChange)??((h=t==null?void 0:t.meta)==null?void 0:h.$nodeChange),n=(p=t==null?void 0:t.meta)==null?void 0:p.$childrenChanges,r=(f=i==null?void 0:i.meta)==null?void 0:f.$nestedChanges,s=(n==null?void 0:n[e])||(r==null?void 0:r[e]),d=this.isAllDescendantsChanged;return["add","remove"].includes((c==null?void 0:c.action)??"")?c:s?{...s,get depth(){const C=d(t,i,n,r);return((t==null?void 0:t.depth)??0)+(C?0:1)}}:void 0}getRequiredChange(o,e){if(!e||typeof o=="number"||!o)return null;const t=e==null?void 0:e.value(),i=t==null?void 0:t.$changes;if(i&&"required"in i&&t&&"required"in t&&Array.isArray(t.required)&&t.required.includes(o)&&i.required){const c=t.required.indexOf(o).toString();if(c in i.required)return i.required[c]}return null}getChildrenChanges(o,e){var n,r,s,d,a,h,p,f,C,S,N;const t={};if((n=e==null?void 0:e[this.metaKey])!=null&&n.properties)for(const l of y(e.properties))t[`${o}/properties/${l}`]=(r=e==null?void 0:e[this.metaKey])==null?void 0:r.properties;const i=((s=e.properties)==null?void 0:s[this.metaKey])??{};for(const l of y(i))t[`${o}/properties/${l}`]=i[l];if((d=e==null?void 0:e[this.metaKey])!=null&&d.additionalProperties&&(t[`${o}/additionalProperties`]=e[this.metaKey].additionalProperties),(a=e==null?void 0:e.items)!=null&&a[this.metaKey]){const l=((h=e==null?void 0:e.items)==null?void 0:h[this.metaKey])??{};for(const $ of y(l))t[`${o}/items/${$.toString()}`]=l[$]}if((p=e==null?void 0:e[this.metaKey])!=null&&p.items){const l=e==null?void 0:e.items;if(T(l))for(const $ of y(l))t[`${o}/items/${$.toString()}`]=e==null?void 0:e[this.metaKey].items;else t[`${o}/items`]=e==null?void 0:e[this.metaKey].items}if((f=e==null?void 0:e[this.metaKey])!=null&&f.additionalItems&&(t[`${o}/additionalItems`]=e[this.metaKey].additionalItems),(C=e==null?void 0:e[this.metaKey])!=null&&C.patternProperties)for(const l of y(e.patternProperties))t[`${o}/patternProperties${x([l])}`]=(S=e==null?void 0:e[this.metaKey])==null?void 0:S.patternProperties;const c=((N=e==null?void 0:e.patternProperties)==null?void 0:N[this.metaKey])??{};for(const l of y(c))t[`${o}/patternProperties${x([l])}`]=c[l];return t}simpleDiffMeta(o){const{value:e,id:t,key:i="",parent:c=null}=o,n=this.getRequiredChange(i,c),r={...n?{required:n}:{},...this.getPropsChanges(e,R)},s=this.getChildrenChanges(t,e??{}),d=this.getNodeChange(o);return{...j(e,R),...d?{$nodeChange:d}:{},...Object.keys(r).length?{$metaChanges:r}:{},...Object.keys(s).length?{$childrenChanges:s}:{},$nodeChangesSummary:new Set,required:k(i,c),...A(e)?{brokenRef:e.$ref}:{},_fragment:e}}nestedDiffMeta(o){var a;const{value:e,id:t,key:i="",parent:c=null}=o,n=q(e),r=((a=e==null?void 0:e[n])==null?void 0:a[this.metaKey])??{},s=this.getNodeChange(o),d={};for(const h of Object.keys(r))d[`${t}/${n}/${h}`]=r[h];return{...Object.keys(d).length?{$nestedChanges:d}:{},...s?{$nodeChange:s}:{},$nodeChangesSummary:new Set,required:k(i,c),...A(e)?{brokenRef:e.$ref}:{},_fragment:e}}}export{H as J};
