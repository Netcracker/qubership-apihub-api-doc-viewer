import{i as b,v as S,w as v,x as q,y as M,U as I,z as T,A as O,B as j,F as R,G as D,H as K,K as y,M as E,N as g,O as k,P as A,Q as x}from"./ErrorBoundaryFallback-7f911bc1.js";class P{static calculateNodeChangesSummary(s,e,t){if(!t)return;const{crawlValue:n}=t;if(!w(n,e))return;const c=n[e];s.meta.$nodeChangesSummary=new Set(Array.from(c).map(r=>r.type))}}function w(l,s){if(!b(l)||!l[s])return!1;const e=l[s];return V(e)}function V(l){if(!(l instanceof Set))return!1;for(const s of l)if(!s||!S(s))return!1;return!0}const J=new Set(["required"]);class H extends v{constructor(s,e,t){super(s),this.metaKey=e,this.aggregatedMetaKey=t}createNode(s,e,t,n,c,r){const o=super.createNode(s,e,t,n,c,r);return P.calculateNodeChangesSummary(o,this.aggregatedMetaKey,r),o}createComplexNode(s,e,t,n,c,r){const o=super.createComplexNode(s,e,t,n,c,r);return P.calculateNodeChangesSummary(o,this.aggregatedMetaKey,r),o}createCycledClone(s,e,t,n){const c=super.createCycledClone(s,e,t,n);return P.calculateNodeChangesSummary(c,this.aggregatedMetaKey,lazyBuildingContext),c}createNodeMeta(s){const{value:e}=s;return q(e)==="simple"?this.simpleDiffMeta(s):this.nestedDiffMeta(s)}createNodeValue(s){const{value:e}=s;if(e==null)return null;if(!b(e))return e;const t=M(e.type)?e.type:I;let n=O[t];const c=e[this.metaKey];if(b(c)&&"type"in c){const o=c.type,i=S(o)&&T(o)&&M(o.beforeValue)?o.beforeValue:void 0;n=[...n,...i?O[i]:[]]}const r=this.getPropsChanges(e,n);return{...j(e,n),...Object.keys(r).length?{$changes:r}:{}}}getPropsChanges(s,e){const t={};if(!b(s))return t;const n=R(s.required);if(n){const o=n[this.metaKey];if(D(o))for(const i of Object.keys(o)){const d=o[i];K(t,d,"required",i)}}const c=R(s.enum);if(c){const o=c[this.metaKey];if(D(o))for(const i of Object.keys(o)){const d=o[i];K(t,d,"enum",i)}}const r=e.filter(o=>!J.has(o));for(const o of r){const i=s[this.metaKey];if(!D(i))continue;const d=i[o];if(!S(d))continue;K(t,d,...[o])}return t}isAllDescendantsChanged(s,e,t,n){let c=!1;if(t){const r=s.children().map(i=>i.id),o=Object.entries(t).filter(([,i])=>i&&!!Object.keys(i).length).map(([i])=>i);c=r.length>0&&o.length>0&&r.length===o.length&&r.every(i=>o.includes(i))&&o.every(i=>t[i].action===t[r[0]].action)}if(n){const r=e.nested.map(i=>i.id),o=Object.entries(n).filter(([,i])=>i&&!!Object.keys(i).length).map(([i])=>i);c=r.length>0&&o.length>0&&r.length===o.length&&r.every(i=>o.includes(i))&&o.every(i=>n[i].action===n[r[0]].action)}return c}getNodeChange(s){var h,u,p,f;const{id:e,parent:t=null,container:n=null}=s,c=((h=n==null?void 0:n.meta)==null?void 0:h.$nodeChange)??((u=t==null?void 0:t.meta)==null?void 0:u.$nodeChange),r=(p=t==null?void 0:t.meta)==null?void 0:p.$childrenChanges,o=(f=n==null?void 0:n.meta)==null?void 0:f.$nestedChanges,i=(r==null?void 0:r[e])||(o==null?void 0:o[e]),d=this.isAllDescendantsChanged;return["add","remove"].includes((c==null?void 0:c.action)??"")?c:i?{...i,get depth(){const C=d(t,n,r,o);return((t==null?void 0:t.depth)??0)+(C?0:1)}}:void 0}getRequiredChange(s,e){if(!e||typeof s=="number"||!s)return null;const t=e==null?void 0:e.value(),n=t==null?void 0:t.$changes;if(n&&"required"in n&&t&&"required"in t&&Array.isArray(t.required)&&t.required.includes(s)&&n.required){const c=t.required.indexOf(s).toString();if(c in n.required)return n.required[c]}return null}getChildrenChanges(s,e){var r,o,i,d,h,u,p,f,C,m,N;const t={};if((r=e==null?void 0:e[this.metaKey])!=null&&r.properties)for(const a of y(e.properties))t[`${s}/properties/${a}`]=(o=e==null?void 0:e[this.metaKey])==null?void 0:o.properties;const n=((i=e.properties)==null?void 0:i[this.metaKey])??{};for(const a of y(n))t[`${s}/properties/${a}`]=n[a];if((d=e==null?void 0:e[this.metaKey])!=null&&d.additionalProperties&&(t[`${s}/additionalProperties`]=e[this.metaKey].additionalProperties),(h=e==null?void 0:e.items)!=null&&h[this.metaKey]){const a=((u=e==null?void 0:e.items)==null?void 0:u[this.metaKey])??{};for(const $ of y(a))t[`${s}/items/${$.toString()}`]=a[$]}if((p=e==null?void 0:e[this.metaKey])!=null&&p.items){const a=e==null?void 0:e.items;if(E(a))for(const $ of y(a))t[`${s}/items/${$.toString()}`]=e==null?void 0:e[this.metaKey].items;else t[`${s}/items`]=e==null?void 0:e[this.metaKey].items}if((f=e==null?void 0:e[this.metaKey])!=null&&f.additionalItems&&(t[`${s}/additionalItems`]=e[this.metaKey].additionalItems),(C=e==null?void 0:e[this.metaKey])!=null&&C.patternProperties)for(const a of y(e.patternProperties))t[`${s}/patternProperties${g([a])}`]=(m=e==null?void 0:e[this.metaKey])==null?void 0:m.patternProperties;const c=((N=e==null?void 0:e.patternProperties)==null?void 0:N[this.metaKey])??{};for(const a of y(c))t[`${s}/patternProperties${g([a])}`]=c[a];return t}simpleDiffMeta(s){const{value:e,id:t,key:n="",parent:c=null}=s,r=this.getRequiredChange(n,c),o={...r?{required:r}:{},...this.getPropsChanges(e,k)},i=this.getChildrenChanges(t,e??{}),d=this.getNodeChange(s);return{...j(e,k),...d?{$nodeChange:d}:{},...Object.keys(o).length?{$metaChanges:o}:{},...Object.keys(i).length?{$childrenChanges:i}:{},$nodeChangesSummary:new Set,required:A(n,c),...x(e)?{brokenRef:e.$ref}:{},_fragment:e}}nestedDiffMeta(s){var h;const{value:e,id:t,key:n="",parent:c=null}=s,r=q(e),o=((h=e==null?void 0:e[r])==null?void 0:h[this.metaKey])??{},i=this.getNodeChange(s),d={};for(const u of Object.keys(o))d[`${t}/${r}/${u}`]=o[u];return{...Object.keys(d).length?{$nestedChanges:d}:{},...i?{$nodeChange:i}:{},$nodeChangesSummary:new Set,required:A(n,c),...x(e)?{brokenRef:e.$ref}:{},_fragment:e}}}export{H as J};
