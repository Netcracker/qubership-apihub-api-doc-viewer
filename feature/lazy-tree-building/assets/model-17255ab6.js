import{i as b,v as m,w as x,x as q,y as g,U as I,z as T,A,B as M,F as O,G as K,H as D,K as u,M as E,N as j,O as R,P as k,Q as v}from"./ErrorBoundaryFallback-7f911bc1.js";class P{static calculateNodeChangesSummary(s,e,t){if(!t)return;const{crawlValue:i}=t;if(!w(i,e))return;const c=i[e];s.meta.$nodeChangesSummary=new Set(Array.from(c).map(r=>r.type))}}function w(y,s){if(!b(y)||!y[s])return!1;const e=y[s];return e instanceof Set?Array.from(e).every(i=>i&&m(i)):!1}const V=new Set(["required"]);class F extends x{constructor(s,e,t){super(s),this.metaKey=e,this.aggregatedMetaKey=t}createNode(s,e,t,i,c,r){const o=super.createNode(s,e,t,i,c,r);return P.calculateNodeChangesSummary(o,this.aggregatedMetaKey,r),o}createComplexNode(s,e,t,i,c,r){const o=super.createComplexNode(s,e,t,i,c,r);return P.calculateNodeChangesSummary(o,this.aggregatedMetaKey,r),o}createCycledClone(s,e,t,i){const c=super.createCycledClone(s,e,t,i);return P.calculateNodeChangesSummary(c,this.aggregatedMetaKey,lazyBuildingContext),c}createNodeMeta(s){const{value:e}=s;return q(e)==="simple"?this.simpleDiffMeta(s):this.nestedDiffMeta(s)}createNodeValue(s){const{value:e}=s;if(e==null)return null;if(!b(e))return e;const t=g(e.type)?e.type:I;let i=A[t];const c=e[this.metaKey];if(b(c)&&"type"in c){const o=c.type,n=m(o)&&T(o)&&g(o.beforeValue)?o.beforeValue:void 0;i=[...i,...n?A[n]:[]]}const r=this.getPropsChanges(e,i);return{...M(e,i),...Object.keys(r).length?{$changes:r}:{}}}getPropsChanges(s,e){const t={};if(!b(s))return t;const i=O(s.required);if(i){const o=i[this.metaKey];if(K(o))for(const n of Object.keys(o)){const a=o[n];D(t,a,"required",n)}}const c=O(s.enum);if(c){const o=c[this.metaKey];if(K(o))for(const n of Object.keys(o)){const a=o[n];D(t,a,"enum",n)}}const r=e.filter(o=>!V.has(o));for(const o of r){const n=s[this.metaKey];if(!K(n))continue;const a=n[o];if(!m(a))continue;D(t,a,...[o])}return t}isAllDescendantsChanged(s,e,t,i){let c=!1;if(t){const r=s.children().map(n=>n.id),o=Object.entries(t).filter(([,n])=>n&&!!Object.keys(n).length).map(([n])=>n);c=r.length>0&&o.length>0&&r.length===o.length&&r.every(n=>o.includes(n))&&o.every(n=>t[n].action===t[r[0]].action)}if(i){const r=e.nested.map(n=>n.id),o=Object.entries(i).filter(([,n])=>n&&!!Object.keys(n).length).map(([n])=>n);c=r.length>0&&o.length>0&&r.length===o.length&&r.every(n=>o.includes(n))&&o.every(n=>i[n].action===i[r[0]].action)}return c}getNodeChange(s){var h,l,p,f;const{id:e,parent:t=null,container:i=null}=s,c=((h=i==null?void 0:i.meta)==null?void 0:h.$nodeChange)??((l=t==null?void 0:t.meta)==null?void 0:l.$nodeChange),r=(p=t==null?void 0:t.meta)==null?void 0:p.$childrenChanges,o=(f=i==null?void 0:i.meta)==null?void 0:f.$nestedChanges,n=(r==null?void 0:r[e])||(o==null?void 0:o[e]),a=this.isAllDescendantsChanged;return["add","remove"].includes((c==null?void 0:c.action)??"")?c:n?{...n,get depth(){const C=a(t,i,r,o);return((t==null?void 0:t.depth)??0)+(C?0:1)}}:void 0}getRequiredChange(s,e){if(!e||typeof s=="number"||!s)return null;const t=e==null?void 0:e.value(),i=t==null?void 0:t.$changes;if(i&&"required"in i&&t&&"required"in t&&Array.isArray(t.required)&&t.required.includes(s)&&i.required){const c=t.required.indexOf(s).toString();if(c in i.required)return i.required[c]}return null}getChildrenChanges(s,e){var r,o,n,a,h,l,p,f,C,S,N;const t={};if((r=e==null?void 0:e[this.metaKey])!=null&&r.properties)for(const d of u(e.properties))t[`${s}/properties/${d}`]=(o=e==null?void 0:e[this.metaKey])==null?void 0:o.properties;const i=((n=e.properties)==null?void 0:n[this.metaKey])??{};for(const d of u(i))t[`${s}/properties/${d}`]=i[d];if((a=e==null?void 0:e[this.metaKey])!=null&&a.additionalProperties&&(t[`${s}/additionalProperties`]=e[this.metaKey].additionalProperties),(h=e==null?void 0:e.items)!=null&&h[this.metaKey]){const d=((l=e==null?void 0:e.items)==null?void 0:l[this.metaKey])??{};for(const $ of u(d))t[`${s}/items/${$.toString()}`]=d[$]}if((p=e==null?void 0:e[this.metaKey])!=null&&p.items){const d=e==null?void 0:e.items;if(E(d))for(const $ of u(d))t[`${s}/items/${$.toString()}`]=e==null?void 0:e[this.metaKey].items;else t[`${s}/items`]=e==null?void 0:e[this.metaKey].items}if((f=e==null?void 0:e[this.metaKey])!=null&&f.additionalItems&&(t[`${s}/additionalItems`]=e[this.metaKey].additionalItems),(C=e==null?void 0:e[this.metaKey])!=null&&C.patternProperties)for(const d of u(e.patternProperties))t[`${s}/patternProperties${j([d])}`]=(S=e==null?void 0:e[this.metaKey])==null?void 0:S.patternProperties;const c=((N=e==null?void 0:e.patternProperties)==null?void 0:N[this.metaKey])??{};for(const d of u(c))t[`${s}/patternProperties${j([d])}`]=c[d];return t}simpleDiffMeta(s){const{value:e,id:t,key:i="",parent:c=null}=s,r=this.getRequiredChange(i,c),o={...r?{required:r}:{},...this.getPropsChanges(e,R)},n=this.getChildrenChanges(t,e??{}),a=this.getNodeChange(s);return{...M(e,R),...a?{$nodeChange:a}:{},...Object.keys(o).length?{$metaChanges:o}:{},...Object.keys(n).length?{$childrenChanges:n}:{},$nodeChangesSummary:new Set,required:k(i,c),...v(e)?{brokenRef:e.$ref}:{},_fragment:e}}nestedDiffMeta(s){var h;const{value:e,id:t,key:i="",parent:c=null}=s,r=q(e),o=((h=e==null?void 0:e[r])==null?void 0:h[this.metaKey])??{},n=this.getNodeChange(s),a={};for(const l of Object.keys(o))a[`${t}/${r}/${l}`]=o[l];return{...Object.keys(a).length?{$nestedChanges:a}:{},...n?{$nodeChange:n}:{},$nodeChangesSummary:new Set,required:k(i,c),...v(e)?{brokenRef:e.$ref}:{},_fragment:e}}}export{F as J};
