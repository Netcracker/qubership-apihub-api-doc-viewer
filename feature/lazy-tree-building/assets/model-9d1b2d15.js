import{i as b,v as P,w as v,x as N,y as S,U as x,z as T,A as g,B as m,F as I,G as M,H as j,K as u,M as V,N as A,O,P as R,Q as k}from"./ErrorBoundaryFallback-bbe3ecbe.js";class K{static calculateNodeChangesSummary(s,e,t){if(!t)return;const{crawlValue:o}=t;if(!w(o,e))return;const c=o[e];s.meta.$nodeChangesSummary=new Set(Array.from(c).map(i=>i.type))}}function w(y,s){if(!b(y)||!y[s])return!1;const e=y[s];return e instanceof Set?Array.from(e).every(o=>o&&P(o)):!1}class U extends v{constructor(s,e,t){super(s),this.metaKey=e,this.aggregatedMetaKey=t}createNode(s,e,t,o,c,i){const n=super.createNode(s,e,t,o,c,i);return K.calculateNodeChangesSummary(n,this.aggregatedMetaKey,i),n}createComplexNode(s,e,t,o,c,i){const n=super.createComplexNode(s,e,t,o,c,i);return K.calculateNodeChangesSummary(n,this.aggregatedMetaKey,i),n}createCycledClone(s,e,t,o){const c=super.createCycledClone(s,e,t,o);return K.calculateNodeChangesSummary(c,this.aggregatedMetaKey,lazyBuildingContext),c}createNodeMeta(s){const{value:e}=s;return N(e)==="simple"?this.simpleDiffMeta(s):this.nestedDiffMeta(s)}createNodeValue(s){const{value:e}=s;if(e==null)return null;if(!b(e))return e;const t=S(e.type)?e.type:x;let o=g[t];const c=e[this.metaKey];if(b(c)&&"type"in c){const n=c.type,r=P(n)&&T(n)&&S(n.beforeValue)?n.beforeValue:void 0;o=[...o,...r?g[r]:[]]}const i=this.getPropsChanges(e,o);return{...m(e,o),...Object.keys(i).length?{$changes:i}:{}}}getPropsChanges(s,e){const t={};if(!b(s))return t;const o=I(s.required);if(o){const i=o[this.metaKey];if(M(i))for(const n of Object.keys(i)){const r=i[n];j(t,r,"required",n)}}const c=e.filter(i=>i!=="required");for(const i of c){const n=s[this.metaKey];if(!M(n))continue;const r=n[i];if(!P(r))continue;j(t,r,...[i])}return t}isAllDescendantsChanged(s,e,t,o){let c=!1;if(t){const i=s.children().map(r=>r.id),n=Object.entries(t).filter(([,r])=>r&&!!Object.keys(r).length).map(([r])=>r);c=i.length>0&&n.length>0&&i.length===n.length&&i.every(r=>n.includes(r))&&n.every(r=>t[r].action===t[i[0]].action)}if(o){const i=e.nested.map(r=>r.id),n=Object.entries(o).filter(([,r])=>r&&!!Object.keys(r).length).map(([r])=>r);c=i.length>0&&n.length>0&&i.length===n.length&&i.every(r=>n.includes(r))&&n.every(r=>o[r].action===o[i[0]].action)}return c}getNodeChange(s){var l,h,p,f;const{id:e,parent:t=null,container:o=null}=s,c=((l=o==null?void 0:o.meta)==null?void 0:l.$nodeChange)??((h=t==null?void 0:t.meta)==null?void 0:h.$nodeChange),i=(p=t==null?void 0:t.meta)==null?void 0:p.$childrenChanges,n=(f=o==null?void 0:o.meta)==null?void 0:f.$nestedChanges,r=(i==null?void 0:i[e])||(n==null?void 0:n[e]),a=this.isAllDescendantsChanged;return["add","remove"].includes((c==null?void 0:c.action)??"")?c:r?{...r,get depth(){const C=a(t,o,i,n);return((t==null?void 0:t.depth)??0)+(C?0:1)}}:void 0}getRequiredChange(s,e){if(!e||typeof s=="number"||!s)return null;const t=e==null?void 0:e.value(),o=t==null?void 0:t.$changes;if(o&&"required"in o&&t&&"required"in t&&Array.isArray(t.required)&&t.required.includes(s)&&o.required){const c=t.required.indexOf(s).toString();if(c in o.required)return o.required[c]}return null}getChildrenChanges(s,e){var i,n,r,a,l,h,p,f,C,D,q;const t={};if((i=e==null?void 0:e[this.metaKey])!=null&&i.properties)for(const d of u(e.properties))t[`${s}/properties/${d}`]=(n=e==null?void 0:e[this.metaKey])==null?void 0:n.properties;const o=((r=e.properties)==null?void 0:r[this.metaKey])??{};for(const d of u(o))t[`${s}/properties/${d}`]=o[d];if((a=e==null?void 0:e[this.metaKey])!=null&&a.additionalProperties&&(t[`${s}/additionalProperties`]=e[this.metaKey].additionalProperties),(l=e==null?void 0:e.items)!=null&&l[this.metaKey]){const d=((h=e==null?void 0:e.items)==null?void 0:h[this.metaKey])??{};for(const $ of u(d))t[`${s}/items/${$.toString()}`]=d[$]}if((p=e==null?void 0:e[this.metaKey])!=null&&p.items){const d=e==null?void 0:e.items;if(V(d))for(const $ of u(d))t[`${s}/items/${$.toString()}`]=e==null?void 0:e[this.metaKey].items;else t[`${s}/items`]=e==null?void 0:e[this.metaKey].items}if((f=e==null?void 0:e[this.metaKey])!=null&&f.additionalItems&&(t[`${s}/additionalItems`]=e[this.metaKey].additionalItems),(C=e==null?void 0:e[this.metaKey])!=null&&C.patternProperties)for(const d of u(e.patternProperties))t[`${s}/patternProperties${A([d])}`]=(D=e==null?void 0:e[this.metaKey])==null?void 0:D.patternProperties;const c=((q=e==null?void 0:e.patternProperties)==null?void 0:q[this.metaKey])??{};for(const d of u(c))t[`${s}/patternProperties${A([d])}`]=c[d];return t}simpleDiffMeta(s){const{value:e,id:t,key:o="",parent:c=null}=s,i=this.getRequiredChange(o,c),n={...i?{required:i}:{},...this.getPropsChanges(e,O)},r=this.getChildrenChanges(t,e??{}),a=this.getNodeChange(s);return{...m(e,O),...a?{$nodeChange:a}:{},...Object.keys(n).length?{$metaChanges:n}:{},...Object.keys(r).length?{$childrenChanges:r}:{},$nodeChangesSummary:new Set,required:R(o,c),...k(e)?{brokenRef:e.$ref}:{},_fragment:e}}nestedDiffMeta(s){var l;const{value:e,id:t,key:o="",parent:c=null}=s,i=N(e),n=((l=e==null?void 0:e[i])==null?void 0:l[this.metaKey])??{},r=this.getNodeChange(s),a={};for(const h of Object.keys(n))a[`${t}/${i}/${h}`]=n[h];return{...Object.keys(a).length?{$nestedChanges:a}:{},...r?{$nodeChange:r}:{},$nodeChangesSummary:new Set,required:R(o,c),...k(e)?{brokenRef:e.$ref}:{},_fragment:e}}}export{U as J};
