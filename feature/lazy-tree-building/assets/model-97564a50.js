import{i as S,v as M,w as O,x as P,y as D,U as x,z as T,A as q,B as g,q as R,F as y,G as v,H as w,K as A,M as j,N as k,O as m}from"./ErrorBoundaryFallback-ca4ed22f.js";class N{static calculateNodeChangesSummary(i,e,t){if(!t)return;const{crawlValue:s}=t;if(!V(s,e))return;const o=s[e];i.meta.$nodeChangesSummary=new Set(Array.from(o).map(r=>r.type))}}function V(u,i){if(!S(u)||!u[i])return!1;const e=u[i];return e instanceof Set?Array.from(e).every(s=>s&&M(s)):!1}class J extends O{constructor(i,e,t){super(i),this.metaKey=e,this.aggregatedMetaKey=t}createNode(i,e,t,s,o,r){const c=super.createNode(i,e,t,s,o,r);return N.calculateNodeChangesSummary(c,this.aggregatedMetaKey,r),c}createComplexNode(i,e,t,s,o,r){const c=super.createComplexNode(i,e,t,s,o,r);return N.calculateNodeChangesSummary(c,this.aggregatedMetaKey,r),c}createCycledClone(i,e,t,s){const o=super.createCycledClone(i,e,t,s);return N.calculateNodeChangesSummary(o,this.aggregatedMetaKey,lazyBuildingContext),o}createNodeMeta(i){const{value:e}=i;return P(e)==="simple"?this.simpleDiffMeta(i):this.nestedDiffMeta(i)}createNodeValue(i){const{value:e}=i;if(e==null)return null;if(!S(e))return e;const t=D(e.type)?e.type:x;let s=q[t];const o=e[this.metaKey];if(S(o)&&"type"in o){const c=o.type,n=M(c)&&T(c)&&D(c.beforeValue)?c.beforeValue:void 0;s=[...s,...n?q[n]:[]]}const r=this.getPropsChanges(e,s);return{...g(e,s),...Object.keys(r).length?{$changes:r}:{}}}getPropsChanges(i,e){const t={},s=new Set;return R(i,({value:o,path:r,key:c})=>{if(s.has(o))return{done:!0};if(s.add(o),r.length===1&&!e.includes(String(c)))return{done:!0};if(!S(o)||!(this.metaKey in o))return{value:o};const n=r.length?o[this.metaKey]:g(o[this.metaKey],e);for(const a of y(n)){const h=[...r,a];v(t,n[a],...h)}}),t}isAllDescendantsChanged(i,e,t,s){let o=!1;if(t){const r=i.children().map(n=>n.id),c=Object.entries(t).filter(([,n])=>n&&!!Object.keys(n).length).map(([n])=>n);o=r.length>0&&c.length>0&&r.length===c.length&&r.every(n=>c.includes(n))&&c.every(n=>t[n].action===t[r[0]].action)}if(s){const r=e.nested.map(n=>n.id),c=Object.entries(s).filter(([,n])=>n&&!!Object.keys(n).length).map(([n])=>n);o=r.length>0&&c.length>0&&r.length===c.length&&r.every(n=>c.includes(n))&&c.every(n=>s[n].action===s[r[0]].action)}return o}getNodeChange(i){var h,l,p,C;const{id:e,parent:t=null,container:s=null}=i,o=((h=s==null?void 0:s.meta)==null?void 0:h.$nodeChange)??((l=t==null?void 0:t.meta)==null?void 0:l.$nodeChange),r=(p=t==null?void 0:t.meta)==null?void 0:p.$childrenChanges,c=(C=s==null?void 0:s.meta)==null?void 0:C.$nestedChanges,n=(r==null?void 0:r[e])||(c==null?void 0:c[e]),a=this.isAllDescendantsChanged;return["add","remove"].includes((o==null?void 0:o.action)??"")?o:n?{...n,get depth(){const $=a(t,s,r,c);return((t==null?void 0:t.depth)??0)+($?0:1)}}:void 0}getRequiredChange(i,e){if(!e||typeof i=="number"||!i)return null;const t=e==null?void 0:e.value(),s=t==null?void 0:t.$changes;if(s&&"required"in s&&t&&"required"in t&&Array.isArray(t.required)&&t.required.includes(i)&&s.required){const o=t.required.indexOf(i).toString();if(o in s.required)return s.required[o]}return null}getChildrenChanges(i,e){var r,c,n,a,h,l,p,C,$,b,f;const t={};if((r=e==null?void 0:e[this.metaKey])!=null&&r.properties)for(const d of y(e.properties))t[`${i}/properties/${d}`]=(c=e==null?void 0:e[this.metaKey])==null?void 0:c.properties;const s=((n=e.properties)==null?void 0:n[this.metaKey])??{};for(const d of y(s))t[`${i}/properties/${d}`]=s[d];if((a=e==null?void 0:e[this.metaKey])!=null&&a.additionalProperties&&(t[`${i}/additionalProperties`]=e[this.metaKey].additionalProperties),(h=e==null?void 0:e.items)!=null&&h[this.metaKey]){const d=((l=e==null?void 0:e.items)==null?void 0:l[this.metaKey])??{};for(const K of y(d))t[`${i}/items/${K.toString()}`]=d[K]}if((p=e==null?void 0:e[this.metaKey])!=null&&p.items){const d=e==null?void 0:e.items;if(w(d))for(const K of y(d))t[`${i}/items/${K.toString()}`]=e==null?void 0:e[this.metaKey].items;else t[`${i}/items`]=e==null?void 0:e[this.metaKey].items}if((C=e==null?void 0:e[this.metaKey])!=null&&C.additionalItems&&(t[`${i}/additionalItems`]=e[this.metaKey].additionalItems),($=e==null?void 0:e[this.metaKey])!=null&&$.patternProperties)for(const d of y(e.patternProperties))t[`${i}/patternProperties${A([d])}`]=(b=e==null?void 0:e[this.metaKey])==null?void 0:b.patternProperties;const o=((f=e==null?void 0:e.patternProperties)==null?void 0:f[this.metaKey])??{};for(const d of y(o))t[`${i}/patternProperties${A([d])}`]=o[d];return t}simpleDiffMeta(i){const{value:e,id:t,key:s="",parent:o=null}=i,r=this.getRequiredChange(s,o),c={...r?{required:r}:{},...this.getPropsChanges(e,j)},n=this.getChildrenChanges(t,e??{}),a=this.getNodeChange(i);return{...g(e,j),...a?{$nodeChange:a}:{},...Object.keys(c).length?{$metaChanges:c}:{},...Object.keys(n).length?{$childrenChanges:n}:{},$nodeChangesSummary:new Set,required:k(s,o),...m(e)?{brokenRef:e.$ref}:{},_fragment:e}}nestedDiffMeta(i){var h;const{value:e,id:t,key:s="",parent:o=null}=i,r=P(e),c=((h=e==null?void 0:e[r])==null?void 0:h[this.metaKey])??{},n=this.getNodeChange(i),a={};for(const l of Object.keys(c))a[`${t}/${r}/${l}`]=c[l];return{...Object.keys(a).length?{$nestedChanges:a}:{},...n?{$nodeChange:n}:{},$nodeChangesSummary:new Set,required:k(s,o),...m(e)?{brokenRef:e.$ref}:{},_fragment:e}}}export{J};
