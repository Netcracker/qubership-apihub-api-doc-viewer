import{i as K,v as P,w as O,x as S,y as g,U as k,z as R,A as q,B as A,F as x,G as T,H as u,K as V,M,N as j,O as m,P as v}from"./ErrorBoundaryFallback-63c7c8d8.js";class b{static calculateNodeChangesSummary(s,e,t){if(!t)return;const{crawlValue:o}=t;if(!w(o,e))return;const n=o[e];s.meta.$nodeChangesSummary=new Set(Array.from(n).map(i=>i.type))}}function w(y,s){if(!K(y)||!y[s])return!1;const e=y[s];return e instanceof Set?Array.from(e).every(o=>o&&P(o)):!1}class J extends O{constructor(s,e,t){super(s),this.metaKey=e,this.aggregatedMetaKey=t}createNode(s,e,t,o,n,i){const c=super.createNode(s,e,t,o,n,i);return b.calculateNodeChangesSummary(c,this.aggregatedMetaKey,i),c}createComplexNode(s,e,t,o,n,i){const c=super.createComplexNode(s,e,t,o,n,i);return b.calculateNodeChangesSummary(c,this.aggregatedMetaKey,i),c}createCycledClone(s,e,t,o){const n=super.createCycledClone(s,e,t,o);return b.calculateNodeChangesSummary(n,this.aggregatedMetaKey,lazyBuildingContext),n}createNodeMeta(s){const{value:e}=s;return S(e)==="simple"?this.simpleDiffMeta(s):this.nestedDiffMeta(s)}createNodeValue(s){const{value:e}=s;if(e==null)return null;if(!K(e))return e;const t=g(e.type)?e.type:k;let o=q[t];const n=e[this.metaKey];if(K(n)&&"type"in n){const c=n.type,r=P(c)&&R(c)&&g(c.beforeValue)?c.beforeValue:void 0;o=[...o,...r?q[r]:[]]}const i=this.getPropsChanges(e,o);return{...A(e,o),...Object.keys(i).length?{$changes:i}:{}}}getPropsChanges(s,e){const t={};if(!K(s))return t;for(const o of e){const n=s[this.metaKey];if(!x(n))continue;const i=n[o];if(!P(i))continue;T(t,i,...[o])}return t}isAllDescendantsChanged(s,e,t,o){let n=!1;if(t){const i=s.children().map(r=>r.id),c=Object.entries(t).filter(([,r])=>r&&!!Object.keys(r).length).map(([r])=>r);n=i.length>0&&c.length>0&&i.length===c.length&&i.every(r=>c.includes(r))&&c.every(r=>t[r].action===t[i[0]].action)}if(o){const i=e.nested.map(r=>r.id),c=Object.entries(o).filter(([,r])=>r&&!!Object.keys(r).length).map(([r])=>r);n=i.length>0&&c.length>0&&i.length===c.length&&i.every(r=>c.includes(r))&&c.every(r=>o[r].action===o[i[0]].action)}return n}getNodeChange(s){var l,h,p,C;const{id:e,parent:t=null,container:o=null}=s,n=((l=o==null?void 0:o.meta)==null?void 0:l.$nodeChange)??((h=t==null?void 0:t.meta)==null?void 0:h.$nodeChange),i=(p=t==null?void 0:t.meta)==null?void 0:p.$childrenChanges,c=(C=o==null?void 0:o.meta)==null?void 0:C.$nestedChanges,r=(i==null?void 0:i[e])||(c==null?void 0:c[e]),d=this.isAllDescendantsChanged;return["add","remove"].includes((n==null?void 0:n.action)??"")?n:r?{...r,get depth(){const $=d(t,o,i,c);return((t==null?void 0:t.depth)??0)+($?0:1)}}:void 0}getRequiredChange(s,e){if(!e||typeof s=="number"||!s)return null;const t=e==null?void 0:e.value(),o=t==null?void 0:t.$changes;if(o&&"required"in o&&t&&"required"in t&&Array.isArray(t.required)&&t.required.includes(s)&&o.required){const n=t.required.indexOf(s).toString();if(n in o.required)return o.required[n]}return null}getChildrenChanges(s,e){var i,c,r,d,l,h,p,C,$,D,N;const t={};if((i=e==null?void 0:e[this.metaKey])!=null&&i.properties)for(const a of u(e.properties))t[`${s}/properties/${a}`]=(c=e==null?void 0:e[this.metaKey])==null?void 0:c.properties;const o=((r=e.properties)==null?void 0:r[this.metaKey])??{};for(const a of u(o))t[`${s}/properties/${a}`]=o[a];if((d=e==null?void 0:e[this.metaKey])!=null&&d.additionalProperties&&(t[`${s}/additionalProperties`]=e[this.metaKey].additionalProperties),(l=e==null?void 0:e.items)!=null&&l[this.metaKey]){const a=((h=e==null?void 0:e.items)==null?void 0:h[this.metaKey])??{};for(const f of u(a))t[`${s}/items/${f.toString()}`]=a[f]}if((p=e==null?void 0:e[this.metaKey])!=null&&p.items){const a=e==null?void 0:e.items;if(V(a))for(const f of u(a))t[`${s}/items/${f.toString()}`]=e==null?void 0:e[this.metaKey].items;else t[`${s}/items`]=e==null?void 0:e[this.metaKey].items}if((C=e==null?void 0:e[this.metaKey])!=null&&C.additionalItems&&(t[`${s}/additionalItems`]=e[this.metaKey].additionalItems),($=e==null?void 0:e[this.metaKey])!=null&&$.patternProperties)for(const a of u(e.patternProperties))t[`${s}/patternProperties${M([a])}`]=(D=e==null?void 0:e[this.metaKey])==null?void 0:D.patternProperties;const n=((N=e==null?void 0:e.patternProperties)==null?void 0:N[this.metaKey])??{};for(const a of u(n))t[`${s}/patternProperties${M([a])}`]=n[a];return t}simpleDiffMeta(s){const{value:e,id:t,key:o="",parent:n=null}=s,i=this.getRequiredChange(o,n),c={...i?{required:i}:{},...this.getPropsChanges(e,j)},r=this.getChildrenChanges(t,e??{}),d=this.getNodeChange(s);return{...A(e,j),...d?{$nodeChange:d}:{},...Object.keys(c).length?{$metaChanges:c}:{},...Object.keys(r).length?{$childrenChanges:r}:{},$nodeChangesSummary:new Set,required:m(o,n),...v(e)?{brokenRef:e.$ref}:{},_fragment:e}}nestedDiffMeta(s){var l;const{value:e,id:t,key:o="",parent:n=null}=s,i=S(e),c=((l=e==null?void 0:e[i])==null?void 0:l[this.metaKey])??{},r=this.getNodeChange(s),d={};for(const h of Object.keys(c))d[`${t}/${i}/${h}`]=c[h];return{...Object.keys(d).length?{$nestedChanges:d}:{},...r?{$nodeChange:r}:{},$nodeChangesSummary:new Set,required:m(o,n),...v(e)?{brokenRef:e.$ref}:{},_fragment:e}}}export{J};
