import{J as T,o as N,i as K,p as D,U as v,q as M,r as R,t as j,u as P,v as A,w as u,x as J,y as V,z as k,A as x,B as O,F as S}from"./ErrorBoundaryFallback-f5de9aeb.js";class I extends T{constructor(t,e){super(t),this.metaKey=e}createNode(t,e,s,o,n,c){return super.createNode(t,e,s,o,n,c)}createComplexNode(t,e,s,o,n,c){return super.createComplexNode(t,e,s,o,n,c)}createCycledClone(t,e,s,o){return super.createCycledClone(t,e,s,o)}createNodeMeta(t){const{value:e}=t;return N(e)==="simple"?this.simpleDiffMeta(t):this.nestedDiffMeta(t)}createNodeValue(t){const{value:e}=t;if(e==null)return null;if(!K(e))return e;const s=D(e.type)?e.type:v;let o=j[s];const n=e[this.metaKey];if(K(n)&&"type"in n){const r=n.type,i=M(r)&&R(r)&&D(r.beforeValue)?r.beforeValue:void 0;o=[...o,...i?j[i]:[]]}const c=this.getPropsChanges(e,o);return{...P(e,o),...Object.keys(c).length?{$changes:c}:{}}}getPropsChanges(t,e){const s={},o=new Set;return A(t,({value:n,path:c,key:r})=>{if(o.has(n))return{done:!0};if(o.add(n),c.length===1&&!e.includes(String(r)))return{done:!0};if(!K(n)||!(this.metaKey in n))return{value:n};const i=c.length?n[this.metaKey]:P(n[this.metaKey],e);for(const l of u(i)){const h=[...c,l];J(s,i[l],...h)}}),s}isAllDescendantsChanged(t,e,s,o){let n=!1;if(s){const c=t.children().map(i=>i.id),r=Object.entries(s).filter(([,i])=>i&&!!Object.keys(i).length).map(([i])=>i);n=c.length>0&&r.length>0&&c.length===r.length&&c.every(i=>r.includes(i))&&r.every(i=>s[i].action===s[c[0]].action)}if(o){const c=e.nested.map(i=>i.id),r=Object.entries(o).filter(([,i])=>i&&!!Object.keys(i).length).map(([i])=>i);n=c.length>0&&r.length>0&&c.length===r.length&&c.every(i=>r.includes(i))&&r.every(i=>o[i].action===o[c[0]].action)}return n}getNodeChange(t){var h,p,y,a;const{id:e,parent:s=null,container:o=null}=t,n=((h=o==null?void 0:o.meta)==null?void 0:h.$nodeChange)??((p=s==null?void 0:s.meta)==null?void 0:p.$nodeChange),c=(y=s==null?void 0:s.meta)==null?void 0:y.$childrenChanges,r=(a=o==null?void 0:o.meta)==null?void 0:a.$nestedChanges,i=(c==null?void 0:c[e])||(r==null?void 0:r[e]),l=this.isAllDescendantsChanged;return["add","remove"].includes((n==null?void 0:n.action)??"")?n:i?{...i,get depth(){const $=l(s,o,c,r);return((s==null?void 0:s.depth)??0)+($?0:1)}}:void 0}getRequiredChange(t,e){if(!e||typeof t=="number"||!t)return null;const s=e==null?void 0:e.value(),o=s==null?void 0:s.$changes;if(o&&"required"in o&&s&&"required"in s&&Array.isArray(s.required)&&s.required.includes(t)&&o.required){const n=s.required.indexOf(t).toString();if(n in o.required)return o.required[n]}return null}getChildrenChanges(t,e){var c,r,i,l,h,p,y,a,$,b,q;const s={};if((c=e==null?void 0:e[this.metaKey])!=null&&c.properties)for(const d of u(e.properties))s[`${t}/properties/${d}`]=(r=e==null?void 0:e[this.metaKey])==null?void 0:r.properties;const o=((i=e.properties)==null?void 0:i[this.metaKey])??{};for(const d of u(o))s[`${t}/properties/${d}`]=o[d];if((l=e==null?void 0:e[this.metaKey])!=null&&l.additionalProperties&&(s[`${t}/additionalProperties`]=e[this.metaKey].additionalProperties),(h=e==null?void 0:e.items)!=null&&h[this.metaKey]){const d=((p=e==null?void 0:e.items)==null?void 0:p[this.metaKey])??{};for(const C of u(d))s[`${t}/items/${C.toString()}`]=d[C]}if((y=e==null?void 0:e[this.metaKey])!=null&&y.items){const d=e==null?void 0:e.items;if(V(d))for(const C of u(d))s[`${t}/items/${C.toString()}`]=e==null?void 0:e[this.metaKey].items;else s[`${t}/items`]=e==null?void 0:e[this.metaKey].items}if((a=e==null?void 0:e[this.metaKey])!=null&&a.additionalItems&&(s[`${t}/additionalItems`]=e[this.metaKey].additionalItems),($=e==null?void 0:e[this.metaKey])!=null&&$.patternProperties)for(const d of u(e.patternProperties))s[`${t}/patternProperties${k([d])}`]=(b=e==null?void 0:e[this.metaKey])==null?void 0:b.patternProperties;const n=((q=e==null?void 0:e.patternProperties)==null?void 0:q[this.metaKey])??{};for(const d of u(n))s[`${t}/patternProperties${k([d])}`]=n[d];return s}simpleDiffMeta(t){const{value:e,id:s,key:o="",parent:n=null}=t,c=this.getRequiredChange(o,n),r={...c?{required:c}:{},...this.getPropsChanges(e,x)},i=this.getChildrenChanges(s,e??{}),l=this.getNodeChange(t);return{...P(e,x),...l?{$nodeChange:l}:{},...Object.keys(r).length?{$metaChanges:r}:{},...Object.keys(i).length?{$childrenChanges:i}:{},required:O(o,n),...S(e)?{brokenRef:e.$ref}:{},_fragment:e}}nestedDiffMeta(t){var h;const{value:e,id:s,key:o="",parent:n=null}=t,c=N(e),r=((h=e==null?void 0:e[c])==null?void 0:h[this.metaKey])??{},i=this.getNodeChange(t),l={};for(const p of u(r))l[`${s}/${c}/${p}`]=r[p];return{...Object.keys(l).length?{$nestedChanges:l}:{},...i?{$nodeChange:i}:{},required:O(o,n),...S(e)?{brokenRef:e.$ref}:{},_fragment:e}}}export{I as J};
