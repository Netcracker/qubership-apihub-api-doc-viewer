import{t as S,u as f,v,w as M,x as R,y as q,i as m,z as D,U as w,A,B as I,F as g,G as K,o as V,H as u,K as E,M as J,N as j,O as k,P as O,Q as T}from"./ErrorBoundaryFallback-9db10c04.js";class U{changesSummary(s,e){var t;if(S(e,s.meta.$metaChanges),S(e,s.meta.$childrenChanges),S(e,s.meta.$nestedChanges),s.type==="simple"){const{required:i,...o}=((t=s.value())==null?void 0:t.$changes)??{};S(e,o)}}totalChangesSummary(s){const e=new Set;return s.isCycle||(this.changesSummary(s,e),!e.size)||this.updateParentNodesChangesSummary(s,e),e}updateParentNodesChangesSummary(s,e){const t=f(s)?s.container:s.parent;t&&(v(e,t.meta.$nodeChangesSummary)||(t.meta.$nodeChangesSummary=M(e,t.meta.$nodeChangesSummary),this.updateParentNodesChangesSummary(t,e)))}}const P=new U;class F extends R{constructor(s,e){super(s),this.metaKey=e}createNode(s,e,t,i,o){const r=super.createNode(s,e,t,i,o);return r.meta.$nodeChangesSummary=P.totalChangesSummary(r),r}createComplexNode(s,e,t,i,o){const r=super.createComplexNode(s,e,t,i,o);return r.meta.$nodeChangesSummary=P.totalChangesSummary(r),r}createCycledClone(s,e,t,i){const o=super.createCycledClone(s,e,t,i);return o.meta.$nodeChangesSummary=P.totalChangesSummary(o),o}createNodeMeta(s){const{value:e}=s;return q(e)==="simple"?this.simpleDiffMeta(s):this.nestedDiffMeta(s)}createNodeValue(s){const{value:e}=s;if(e==null)return null;if(!m(e))return e;const t=D(e.type)?e.type:w;let i=g[t];const o=e[this.metaKey];if(m(o)&&"type"in o){const c=o.type,n=A(c)&&I(c)&&D(c.beforeValue)?c.beforeValue:void 0;i=[...i,...n?g[n]:[]]}const r=this.getPropsChanges(e,i);return{...K(e,i),...Object.keys(r).length?{$changes:r}:{}}}getPropsChanges(s,e){const t={},i=new Set;return V(s,({value:o,path:r,key:c})=>{if(i.has(o))return{done:!0};if(i.add(o),r.length===1&&!e.includes(String(c)))return{done:!0};if(!m(o)||!(this.metaKey in o))return{value:o};const n=r.length?o[this.metaKey]:K(o[this.metaKey],e);for(const h of u(n)){const d=[...r,h];E(t,n[h],...d)}}),t}isAllDescendantsChanged(s,e,t,i){let o=!1;if(t){const r=s.children().map(n=>n.id),c=Object.entries(t).filter(([,n])=>n&&!!Object.keys(n).length).map(([n])=>n);o=r.length>0&&c.length>0&&r.length===c.length&&r.every(n=>c.includes(n))&&c.every(n=>t[n].action===t[r[0]].action)}if(i){const r=e.nested.map(n=>n.id),c=Object.entries(i).filter(([,n])=>n&&!!Object.keys(n).length).map(([n])=>n);o=r.length>0&&c.length>0&&r.length===c.length&&r.every(n=>c.includes(n))&&c.every(n=>i[n].action===i[r[0]].action)}return o}getNodeChange(s){var d,l,y,p;const{id:e,parent:t=null,container:i=null}=s,o=((d=i==null?void 0:i.meta)==null?void 0:d.$nodeChange)??((l=t==null?void 0:t.meta)==null?void 0:l.$nodeChange),r=(y=t==null?void 0:t.meta)==null?void 0:y.$childrenChanges,c=(p=i==null?void 0:i.meta)==null?void 0:p.$nestedChanges,n=(r==null?void 0:r[e])||(c==null?void 0:c[e]),h=this.isAllDescendantsChanged;return["add","remove"].includes((o==null?void 0:o.action)??"")?o:n?{...n,get depth(){const C=h(t,i,r,c);return((t==null?void 0:t.depth)??0)+(C?0:1)}}:void 0}getRequiredChange(s,e){if(!e||typeof s=="number"||!s)return null;const t=e==null?void 0:e.value(),i=t==null?void 0:t.$changes;if(i&&"required"in i&&t&&"required"in t&&Array.isArray(t.required)&&t.required.includes(s)&&i.required){const o=t.required.indexOf(s).toString();if(o in i.required)return i.required[o]}return null}getChildrenChanges(s,e){var r,c,n,h,d,l,y,p,C,N,b;const t={};if((r=e==null?void 0:e[this.metaKey])!=null&&r.properties)for(const a of u(e.properties))t[`${s}/properties/${a}`]=(c=e==null?void 0:e[this.metaKey])==null?void 0:c.properties;const i=((n=e.properties)==null?void 0:n[this.metaKey])??{};for(const a of u(i))t[`${s}/properties/${a}`]=i[a];if((h=e==null?void 0:e[this.metaKey])!=null&&h.additionalProperties&&(t[`${s}/additionalProperties`]=e[this.metaKey].additionalProperties),(d=e==null?void 0:e.items)!=null&&d[this.metaKey]){const a=((l=e==null?void 0:e.items)==null?void 0:l[this.metaKey])??{};for(const $ of u(a))t[`${s}/items/${$.toString()}`]=a[$]}if((y=e==null?void 0:e[this.metaKey])!=null&&y.items){const a=e==null?void 0:e.items;if(J(a))for(const $ of u(a))t[`${s}/items/${$.toString()}`]=e==null?void 0:e[this.metaKey].items;else t[`${s}/items`]=e==null?void 0:e[this.metaKey].items}if((p=e==null?void 0:e[this.metaKey])!=null&&p.additionalItems&&(t[`${s}/additionalItems`]=e[this.metaKey].additionalItems),(C=e==null?void 0:e[this.metaKey])!=null&&C.patternProperties)for(const a of u(e.patternProperties))t[`${s}/patternProperties${j([a])}`]=(N=e==null?void 0:e[this.metaKey])==null?void 0:N.patternProperties;const o=((b=e==null?void 0:e.patternProperties)==null?void 0:b[this.metaKey])??{};for(const a of u(o))t[`${s}/patternProperties${j([a])}`]=o[a];return t}simpleDiffMeta(s){const{value:e,id:t,key:i="",parent:o=null}=s,r=this.getRequiredChange(i,o),c={...r?{required:r}:{},...this.getPropsChanges(e,k)},n=this.getChildrenChanges(t,e??{}),h=this.getNodeChange(s);return{...K(e,k),...h?{$nodeChange:h}:{},...Object.keys(c).length?{$metaChanges:c}:{},...Object.keys(n).length?{$childrenChanges:n}:{},$nodeChangesSummary:new Set,required:O(i,o),...T(e)?{brokenRef:e.$ref}:{},_fragment:e}}nestedDiffMeta(s){var d;const{value:e,id:t,key:i="",parent:o=null}=s,r=q(e),c=((d=e==null?void 0:e[r])==null?void 0:d[this.metaKey])??{},n=this.getNodeChange(s),h={};for(const l of u(c))h[`${t}/${r}/${l}`]=c[l];return{...Object.keys(h).length?{$nestedChanges:h}:{},...n?{$nodeChange:n}:{},$nodeChangesSummary:new Set,required:O(i,o),...T(e)?{brokenRef:e.$ref}:{},_fragment:e}}}export{F as J};
